function [dataflow, prmflow, status] = reconnode_nonlinearcali(dataflow, prmflow, status)
% nonlinear calibration
% [dataflow, prmflow, status] = reconnode_nonlinearcali(dataflow, prmflow, status)

% parameters to use in prmflow
Npixel = prmflow.recon.Npixel;
Nslice = prmflow.recon.Nslice;
Nps = Npixel*Nslice;
Nview = prmflow.recon.Nview;

% parameters to use
if ~isempty(status)
    caliprm = prmflow.pipe.(status.nodename);
else
    % for debug
    caliprm = struct();     
end

% polynomial order
if isfield(caliprm, 'polyorder')
    n_poly = caliprm.polyorder;
else
    % order of nonlinear poly, default is 2
    n_poly = 2;
    % NOTE: large order could be unstable
end
% fit weighting
if isfield(caliprm, 'weight')
    fit_weight = caliprm.weight(:);
else
    fit_weight = [];
end
% HCscale
if isfield(caliprm, 'HCscale')
    HCscale = caliprm.HCscale;
else
    HCscale = 1000;
end
% format version of calibration table
if isfield(caliprm, 'corrversion')
    corrversion = caliprm.corrversion;
else
    corrversion = 'v1.0';
end
% echo .
echo_onoff = true;

% I know the input data are rawdata_bk1, rawdata_bk2 ...
% find out them
datafields = findfields(dataflow, '\<rawdata_bk');
Nbk = length(datafields);
% I know Nbk must be even
% and the rawhead
headfields = findfields(dataflow, '\<rawhead_bk');

% reshape
for ibk = 1:Nbk
    dataflow.(datafields{ibk}) = reshape(dataflow.(datafields{ibk}), Nps, Nview);
end

% index range
index_range = zeros(2, Nslice, Nview, Nbk/2);
for ibk = 1:Nbk/2
    index_range(:,:,:, ibk) = reshape(dataflow.(headfields{ibk}).index_range, 2, Nslice, Nview);
end

% ini the buffer to use
x = zeros(Nbk/2, Nview);
y = zeros(Nbk/2, Nview);
% ini the coefficients of the polynomal
poly_nonl = nan(Npixel*Nslice, n_poly);
% fitting option
options = optimoptions('lsqnonlin','Display','off');
% initial value of the fitting
t0 = zeros(1, n_poly);
t0(n_poly) = 1.0;

weight = ones(Nbk/2, 1);
% input weight?
if ~isempty(fit_weight)
    if length(fit_weight)>=Nbk/2
        weight = fit_weight(1:Nbk/2);
    else
        weight(1:length(fit_weight)) = fit_weight;
    end
end
% debug
% weight = [0 1 0 1]';

w = repmat(weight, 1, Nview);

% loop the pixels to fit the polynomal for each
for islice = 1:Nslice
    if echo_onoff, fprintf('.'); end
    % index range
    Srange = zeros(Npixel, Nview, Nbk/2);
    for ibk = 1:Nbk/2
        for iview = 1:Nview
            Srange(index_range(1, islice, iview, ibk) : index_range(2, islice, iview, ibk), iview, ibk) = 1;
        end
    end
    
    % For each slice we will start from the middle pixel that will be more stable though a little troublesome.
    midu = floor(Npixel/2);
    % ini the initial value for ipixel
    t0_ipx = t0;
    p_fix = 0;
    % loop from midu+1 to end, then from midu to 1
    loopindex = [(midu+1:Npixel) (midu:-1:1)];
    for ii = 1:Npixel
        index = loopindex(ii);
        % reset t0 when restart from midu
        if index == midu
            t0_ipx = t0;
        end
        % pixel index
        ipixel = index+(islice-1)*Npixel;
        % set the data to fit
        [x, y, s] = getdatatofit(dataflow, datafields, index, ipixel, Nbk, Nview, HCscale, Srange);
%         for ibk = 1:Nbk/2
%             % x is the original data in fitting
%             ix = ibk*2-1;   % 1 3 5 7
%             x(ibk, :) = double(dataflow.(datafields{ix})(ipixel, :)) ./ HCscale;
%             % y is the target data
%             iy = ibk*2;     % 2 4 6 8
%             y(ibk, :) = double(dataflow.(datafields{iy})(ipixel, :)) ./ HCscale;
%             % cut y by index range
%             y(ibk, :) = y(ibk, :).*Srange(index, :, ibk);
%         end
%         % Is there enough available data for fitting?
%         s = y>0;

        % Is there enough available data for fitting?
        s_sum = sum(s, 2);
        s_avail = s_sum>=Nview/4;
        if all(~s_avail)
            % skip this pixel 
            continue;
        end     
        
        % fit f(x) to y
        p_ipx = calipolyfit(x(s), y(s), w(s), t0_ipx);
        % set the initial value for next pixel
        t0_ipx = p_ipx;
        
%         % the algorithm is reverse generator base on lsqnonlin
%         p_ipx = lsqnonlin(@(t) (iterinvpolyval(t, y(s))-x(s)).*w(s), t0_ipx, [], [], options);
%         if p_ipx(1)>0.5
%             % unstable? redo the fitting start with t0
%             p_ipx = lsqnonlin(@(t) (iterinvpolyval(t, y(s))-x(s)).*w(s), t0, [], [], options);
%         end       
        if any(~s_avail)
            % fix the p
            if any(s_avail~=prev_avial)
                % calculate p fix
                % go back to previous pixel
                index_prev = loopindex(ii-1);
                ipixel_prev = index_prev+(islice-1)*Npixel;
                [x, y, s] = getdatatofit(dataflow, datafields, index_prev, ipixel_prev, Nbk, Nview, HCscale, Srange);
                % remove the s not availale in current pixel
                s(~s_avail, :) = false;
                % redo the fitting
                p_redo = calipolyfit(x(s), y(s), w(s), t0_ipx);
                % I know the previous p was t0_ipx
                p_fix = t0_ipx-p_prev;
            end
            % + p_fix
            p_ipx = p_ipx + p_fix;
        end
        % update previous values
        prev_avial = s_avail;
        p_prev = p_ipx;

        
        
        % copy to result buffer
        poly_nonl(ipixel, :) = p_ipx;
    end
    
end
% fillup nan
poly_nonl = reshape(fillmissing(reshape(poly_nonl, Npixel, []), 'nearest'), [], n_poly);

% debug
poly_nonl = reshape(poly_nonl, Npixel, Nslice, n_poly);
poly_nonl(1:214,:,1) = 0;
poly_nonl(1:214,:,2) = 1;
poly_nonl(642:end,:,1) = 0;
poly_nonl(642:end,:,2) = 1;
poly_nonl = reshape(poly_nonl, [], n_poly);

% mix with provious nonlinear table
if isfield(prmflow.corrtable, 'Nonlinear')
    poly_prv = reshape(prmflow.corrtable.Nonlinear.main, Nps, []);
    n_poly_prv = size(poly_prv, 2);
    % merge
    poly_merge = mergeiterpoly3to5(poly_prv, poly_nonl);
    % new poly
    n_poly = min( max(n_poly, n_poly_prv)+1, 5);
    poly_nonl = poly_merge(:, end-n_poly+1:end);
end

% paramters for corr
nonlinearcorr = caliprmforcorr(prmflow, corrversion);
% copy results to corr
nonlinearcorr.Nslice = Nslice;
nonlinearcorr.order = n_poly;
nonlinearcorr.mainsize = Nps*n_poly;
nonlinearcorr.main = poly_nonl;

% to return
dataflow.nonlinearcorr = nonlinearcorr;

% status
status.jobdone = true;
status.errorcode = 0;
status.errormsg = [];
end


function [x, y, s] = getdatatofit(dataflow, datafields, index, ipixel, Nbk, Nview, HCscale, Srange)
% get the data to fit

x = zeros(Nbk/2, Nview);
y = zeros(Nbk/2, Nview);

for ibk = 1:Nbk/2
    % x is the original data in fitting
    ix = ibk*2-1;   % 1 3 5 7
    x(ibk, :) = double(dataflow.(datafields{ix})(ipixel, :)) ./ HCscale;
    % y is the target data
    iy = ibk*2;     % 2 4 6 8
    y(ibk, :) = double(dataflow.(datafields{iy})(ipixel, :)) ./ HCscale;
    % cut y by index range
    y(ibk, :) = y(ibk, :).*Srange(index, :, ibk);
end
% available data
s = y>0;

end


function p = calipolyfit(x, y, w, t0)
% fit f(x) to y by looking for a polynomial f: min(||(x-f^{-1}(y)).*w||)

options = optimoptions('lsqnonlin','Display','off');
% the algorithm is reverse generator base on lsqnonlin
p = lsqnonlin(@(t) (iterinvpolyval(t, y)-x).*w, t0, [], [], options);
if p(1)>0.5
    % unstable? redo the fitting start with [0, 1]
    t0 = zeros(size(t0));
    t0(end) = 1;
    p = lsqnonlin(@(t) (iterinvpolyval(t, y)-x).*w, t0, [], [], options);
end
end


function r = mergeiterpoly3to5(a, b)
% to merge two polymal only for <=3 order and only output order 1-5 

[n, Na] = size(a);
Nb = size(b, 2);

if Na>3
    a = a(:, end-2:end);
elseif Na<3
    tmp = a;
    a = zeros(n, 3);
    a(:,end-Na+1:end) = tmp;
end

if Nb>3
    b = b(:,end-2:end);
elseif Nb<3
    tmp = b;
    b = zeros(n, 3);
    b(:, end-Na+1:end) = tmp;
end

% I know
% f(r, x) = b1*b2*b3*a1^3*a2^3*a3^3*x^9 + 3*b1*b2*b3*a1^2*a2^3*a3^3*x^8 + 3*b1*b2*b3*a1^2*a2^2*a3^3*x^7 + 
%           b2*b3*a1^2*a2^2*a3^2*x^6 + 3*b1*b2*b3*a1*a2^3*a3^3*x^7 + 6*b1*b2*b3*a1*a2^2*a3^3*x^6 + 2*b2*b3*a1*a2^2*a3^2*x^5 + 
%           3*b1*b2*b3*a1*a2*a3^3*x^5 + 2*b2*b3*a1*a2*a3^2*x^4 + b3*a1*a2*a3*x^3 + b1*b2*b3*a2^3*a3^3*x^6 + 
%           3*b1*b2*b3*a2^2*a3^3*x^5 + b2*b3*a2^2*a3^2*x^4 + 3*b1*b2*b3*a2*a3^3*x^4 + 2*b2*b3*a2*a3^2*x^3 + b3*a2*a3*x^2 + 
%           b1*b2*b3*a3^3*x^3 + b2*b3*a3^2*x^2 + b3*a3*x

m = 5;
r = zeros(n , m);
% 1
r(:, m) = a(:,3).*b(:,3);
% 2
c2 = b(:,2).*a(:,3) + a(:,2);
r(:, m-1) = c2;
% 3
c3 = b(:,1).*b(:,2).*a(:,3).^2 + 2.*b(:,2).*a(:,2).*a(:,3) + a(:,1).*a(:,2);
r(:, m-2) = c3./c2;
% 4
c4 = a(:,2).*a(:,3).*b(:,2).*(2.*a(:,1) + a(:,2) + 3.*a(:,3).*b(:,1));
r(:, m-3) = c4./c3;
% 5
c5 = a(:,2).*a(:,3).*b(:,2).*(2.*a(:,1).*a(:,2) + 3.*a(:,1).*a(:,3).*b(:,1) + 3.*a(:,2).*a(:,3).*b(:,1));
r(:, m-4) = c5./c4;

% skip nan
r(~isfinite(r)) = 0;
s = [abs(r(:,1:m-1))>0.5 false(n, 1)];
r(s) = 0;

end
